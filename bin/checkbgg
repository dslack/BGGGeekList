#!/usr/bin/env node

var dir = process.env.OPENSHIFT_REPO_DIR || '../';

var	_		=	require('lodash'),
	fs		=	require('fs-extra'),
	moment	=	require('moment'),
	Q		=	require('q'),
	GeekList=	require('./geeklist'),
	Games 	=	require('./games'),
	PubNotes=	require('./scrape');

var urls = {
	//geeklist: 184821,
	//released: 192268
	geeklist: 174654,
	released: null

};

var lists = [geeklistRetrieval(), releasedRetrieval()];

Q.all(lists)
	.then(handleGamesRetrieval)
	.catch(function(err){
		console.error(err);
	});


function geeklistRetrieval(){
	return GeekList.getGeekList(urls.geeklist)
		.then(GeekList.transformData)
		.then(GeekList.reorder)
		.then(GeekList.stripResultsData);
}

function releasedRetrieval() {
	if (!urls.released) {
		return Q.when([]);
	}
	return GeekList.getGeekList(urls.released)
		.then(GeekList.transformData)
		.then(GeekList.reorder)
		.then(GeekList.stripResultsData);
}

function gamesRetrieval(items) {
	return Games.getGameIds(items)
			.then(Games.retrieveGames)
			.then(GeekList.transformData)
			.then(Games.stripGamesData);
}


function handleGamesRetrieval(results){
	var items = results[0];
	var releases = results[1];
	return Q.Promise(function(resolve, reject) {
		//lets also get the games to be released (according to https://boardgamegeek.com/geeklist/192268/games-releasing-gen-con-2015)
		var promises = [];
		promises.push(gamesRetrieval(items));
		promises.push(PubNotes());

		Q.all(promises).done(function(values){
			var games = values[0];
			var publisherAndNotes = values[1];
			mergeResultsAndGames(items, releases, games, publisherAndNotes)
				.then(saveResultsFile)
				.catch(reject);
		});
		/*gamesRetrieval(items)
			.then(function(games){
				//now, lets take the games, and the items, and merge them, then send them to the saveResults
				return mergeResultsAndGames(items, releases, games)
			})
		.then(saveGamesFile)*/
	});
}

function mergeResultsAndGames(items, releases, games, publisherNotes) {
	console.log("Merging Results and Games");
	return Q.Promise(function(resolve, reject){
		//so, for each item, there is a game...
		var gMap = gamesAsMap(games);
		var pubNotes = publisherAndNotesAsMap(publisherNotes);
		_.each(items, function(item) {
			var released = _.find(releases, function(r) {
				return r.objectid === item.objectid;
			});
			var game = gMap[item.objectid];
			item.publishers = mapJustUnderscore(game.publishers);
			item.designers = mapJustUnderscore(game.designers);
			item.description = game.description[0];
			item.released = (!!released);
			if (pubNotes[item.mainpublisher] && pubNotes[item.mainpublisher].notes) {
				item.publisherNotes = pubNotes[item.mainpublisher].notes;
			}
		});

		resolve(items);
	});
}

function mapJustUnderscore(data) {
	return _.map(data, function(d) {
		return d._;
	});
}

function gamesAsMap(games) {
	return _.chain(games.boardgames)
		.indexBy('objectid')
		.transform(function(result, value, key) {
			result[key] = value;
		})
		.value();
}

function publisherAndNotesAsMap(pubNotes){
	return _.chain(pubNotes)
		.indexBy('publisher')
		.transform(function(result, value, key) {
			result[key] = value;
		})
		.value();
}

function saveResultsFile(items){
	console.log("Writting out Results File");
	return Q.Promise(function(resolve, reject) {
		fs.writeJSON(dir+'app/results.json', {refreshed: moment().toISOString(), items: items}, function(err){
			if (err) {
				reject(new Error(err));
			} else {
				resolve(items);
			}
		});
	});
}

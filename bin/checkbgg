#!/usr/bin/env node

var dir = process.env.OPENSHIFT_REPO_DIR || '../';

var	_		=	require('lodash'),
	fs		=	require('fs-extra'),
	moment	=	require('moment'),
	Q		=	require('q'),
	GenCon 	=	require('./gencon'),
	GeekList=	require('./geeklist'),
	Games 	=	require('./games');

var urls = {
	gencon: 184821,
	released: 192268
};

function genConRetrieval(){
	return GeekList.getGeekList(urls.gencon)
		.then(GeekList.transformData)
		.then(GenCon.reorder)
		.then(GenCon.stripResultsData);
}

function releasedRetrieval() {
	return GeekList.getGeekList(urls.released)
		.then(GeekList.transformData)
		.then(GenCon.reorder)
		.then(GenCon.stripResultsData);
}

function gamesRetrieval(items) {
	return Games.getGameIds(items)
			.then(Games.retrieveGames)
			.then(GeekList.transformData)
			.then(Games.stripGamesData);
}


Q.all([genConRetrieval(), releasedRetrieval()])
	.then(handleGamesRetrieval)
	.catch(function(err){
		console.error(err);
	});


function handleGamesRetrieval(results){
	var items = results[0];
	var releases = results[1];
	return Q.Promise(function(resolve, reject) {
		//lets also get the games to be released (according to https://boardgamegeek.com/geeklist/192268/games-releasing-gen-con-2015)
		gamesRetrieval(items)
			.then(function(games){
				//now, lets take the games, and the items, and merge them, then send them to the saveResults
				return mergeResultsAndGames(items, releases, games)
			})
			.then(saveResultsFile)
			.catch(reject);
		//.then(saveGamesFile)
	});
}

function mergeResultsAndGames(items, releases, games) {
	console.log("Merging Results and Games");
	return Q.Promise(function(resolve, reject){
		//so, for each item, there is a game...
		var gMap = gamesAsMap(games);
		_.each(items, function(item) {
			var released = _.find(releases, function(r) {
				return r.objectid === item.objectid;
			});
			var game = gMap[item.objectid];
			item.publishers = mapJustUnderscore(game.publishers);
			item.designers = mapJustUnderscore(game.designers);
			item.description = game.description[0];
			item.released = (!!released);
		});

		resolve(items);
	});
}

function mapJustUnderscore(data) {
	return _.map(data, function(d) {
		return d._;
	});
}

function gamesAsMap(games) {
	return _.chain(games.boardgames)
		.indexBy('objectid')
		.transform(function(result, value, key) {
			result[key] = value;
		})
		.value();
}

function saveResultsFile(items){
	console.log("Writting out Results File");
	return Q.Promise(function(resolve, reject) {
		fs.writeJSON(dir+'app/results.json', {refreshed: moment().toISOString(), items: items}, function(err){
			if (err) {
				reject(new Error(err));
			} else {
				resolve(items);
			}
		});
	});
}
